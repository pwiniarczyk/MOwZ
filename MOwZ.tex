\documentclass[12pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}  	
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\begin{document}
\lstset{language=Pascal}
Metody Optymalizacji w Zarządzaniu
\newpage
\tableofcontents
\section{Przydział miejsc w parlamencie}
\subsection{Sformułowanie problemu}
\begin{description}
\item[s] liczba stanów
\item [p ]wektor populacji
\begin{equation}
p=[p_1, p_2, ... , p_s]
\end{equation}
\item [h] rozmiar parlamentu
\item[kwota] idealny podział
\item[r] minimalny przydział miejsc
\begin{equation}
r=[r_1, r_2, ... , r_s]
\end{equation}
\end{description}
\subsection{Metoda podziału}
Metodą podziału M (apportionment method) nazywamy regułę, która dla każdego s-elementowego wektora $ p>0 $ i liczby całkowitej $h  >0$ określa co najmniej jeden s-elementowy wektor a liczb całkowitych, taki, że ???TODO
\subsection{Podział}
Podziałem otrzymanym za pomocą metody M
 nazywamy funkcję f, taką, że 
 $f(p, h) =  a \in M(p, h)$
\subsection{metoda homogeniczna}
Metodę nazywamy homogeniczną, jeżeli każdy podział otrzymany za pomocą metody M dla wektora p i liczby h jest identyczny, jak podział dla wektora $\lambda p$ i liczby h, dla
dowolnej dodatnie liczby wymiernej $ \lambda$. 
\subsection{Metoda symetryczna}
Metodę nazywamy symetryczną, gdy podział zależy wyłącznie od wielkości populacji, a nie innej charakterystyki ubiegających się o zasób (stanów).
\subsection{Metody sprawiedliwego podziału}
\begin{itemize}
\item Metoda Hamiltona
\item Metody dzielnikowe
\item Metoda kwotowa Balinskiego i Younga
\item Metoda Stilla
\end{itemize}
\subsection{Metoda Hamiltona}
Procedura
\begin{enumerate}
\item Oblicz dzielnik standardowy
\begin{equation}
SD=\frac{populacje\ kraju}{rozmiar\ parlamentu}
\end{equation}
\item Oblicz kwoty standardowe dla poszczególnych stanów 
\begin{equation}
SQ_i	=\frac{populacje\ stanu \ i}{SD}
\end{equation}
\item Początkowo przydziel każdemu stanowi jego dolną kwotę(kwotę zaokrągloną w dół)
\item Jeżeli pozostał nieprzydzielone miejsca to przydziel je kolejno
stanom o największej części ułamkowej kwoty standardowej.
\end{enumerate}
\subsection{Metoda Jeffersona}
Procedura
\begin{enumerate}
\item Oblicz dzielnik standardowy 
\item Oblicz kwoty standardowe dla poszczególnych stanów 

\item Początkowo przydziel każdemu stanowi jego dolną kwotę
\item  Jeżeli suma dolnych kwot jest równa
rozmiarowi parlamentu to przydziel
stanom taką liczbę miejsc.
\item W przeciwnym razie metodą prób i błędów znajdź liczbę MD
(zmodyfikowany dzielnik) tak, aby zmodyfikowane kwoty
(MQ) zaokrąglone w dół sumowały się do rozmiaru parlamentu.
Przydziel każdemu stanowi liczbę miejsc równą jego dolnej
zmodyfikowanej kwocie.
\end{enumerate}
\subsection{Metody dzielnikowe}
\subsubsection{Kryterium porównawcze}
Jest to uporządkowany zbiór wszystkich par (p, a), gdzie p oznacza liczbę mieszkańców, zaś a liczbę mandatów, które można by danemu stanowi przydzielić. Każda para (p, a) znajduje się w uporządkowaniu przed (p, a + 1).
\subsubsection{Metoda dzielnikowa}
Metoda, w której kryterium porównawcze jest reprezentowane przez indeks uporządkowania postaci:
TODO

gdzie d(a) jest ściśle rosnącą rzeczywistą funkcją określoną na nieujemnych liczbach całkowitych.

\subsubsection{Metody dzielnikowe}
\begin{center}
    \begin{tabular}{ | l  |l |}
    \hline
    metoda  & d(a) \\ \hline
    Adamsa & a \\ \hline
    Deana& \\ \hline
    Hilla & \\ \hline
    Webster & \\ \hline
    Jeffersona& a+1 \\ \hline
    
    \end{tabular}
\end{center}
\subsection{Zachowanie dolnej kwoty} TODO
\subsubsection{Zachowanie górnej kwoty} TODO
\subsubsection{Metoda kwotowa (Balinski, Young)}

Zbiór E(p,a) zawiera wszystkie te stany, które mogą otrzymać dodatkowy mandat bez naruszenia górnej kwoty.

Wybiera się stan o największej wartości pi /(ai+1). Jest monotoniczna ze względu na rozmiar parlamentu. 

\subsubsection{Metoda kwotowa (Still)}
\begin{enumerate}
\item Dla h = 0 przyporządkuj a = 0
\item Dla $h > 0$ przydziel kolejne miejsce stanowi ze
zbioru E(h).
\end{enumerate}

Definicja zbioru E(h)
\begin{enumerate}
\item  Liczba mandatów, które przydzielono stanowi i w parlamencie o rozmiarze h nie przekracza „górnej” kwoty.
\item Stan i spełnia test dolnej kwoty (Stilla).
\end{enumerate}

Test dolnej kwoty (Stilla).
\begin{enumerate}
\item Niech hi będzie rozmiarem parlamentu, w którym stan i po raz pierwszy powinien
otrzymać kolejny mandat, czyli hi jest najmniejszą z liczb 
$h' \geq h $ , dla której  $q (h )  \geq a  (h -1 )+1. $ 
\item Dla każdego g, będącego rozmiarem parlamentu, $h \leq g < h_i $ zdefiniujmy:
\begin{itemize}
\item si(g, i ) = ai(h – 1) + 1.
\item $sj(g, i ) = max \lbrace ai(h – 1), qi(g) \rbrace \  dla \  j \neq i $,
\end{itemize}
\item Jeżeli nie istnieje g takie, że $h \leqslant g \leqslant hi $, dla którego TODO

To stan i spełnia test dolnej kwoty czyli i $ \in $ E(h)
\end{enumerate}

\subsubsection{Własności metod podziału}
\begin{itemize}
\item Metoda jest \textbf{monotoniczna ze względu na rozmiar parlamentu} jeżeli w wypadku zwiększenia dostępnej liczby mandatów, liczba mandatów przydzielonych do każdego stanu będzie nie mniejsza niż poprzednio.
\item Metoda jest \textbf{parami zgodna} (jednorodna - uniform), jeżeli dla każdych dwóch stanów dysponujących łącznie określoną liczbą mandatów podział mandatów pomiędzy te stany jest niezależny od obecności innych stanów.

\item Metoda jest monotoniczna ze względu na wektor populacji jeżeli dla wektorów p, p’ i przydziałów $a\in M(p,h)$, $a’\in M(p’,h)$ zachodzi:

TODO 

\item Każda metoda monotoniczna ze względu na wektor populacji jest monotoniczna ze względu na rozmiar parlamentu.

\end{itemize}

\subsubsection{Twierdzenie o niemożliwości}

Nie istnieje metoda podziału miejsc dla co najmniej czterech stanów i parlamentu o rozmiarze
$h \geq $ liczba stanów +3, która byłaby monotoniczna ze względu na wektor populacji i jednocześnie spełniała warunek kwoty.

Wniosek

\begin{itemize}
\item Żadna z metod dzielnikowych nie zachowuje kwoty.
\item Metoda Stilla nie jest monotoniczna ze względu na wektor populacji, bo zachowuje kwotę.
\end{itemize}

\begin{center}
    \begin{tabular}{ | p{5cm} |l | l |}
    \hline
      & Zachowuje kwote &Nie zachowuje kwoty \\ \hline
    Monotonczine ze wzgledu na rozm parlamentu & Still, Balinski-Young& Metody dzielnikowe \\ \hline
    Niemonotonczine ze wzgledu na rozm parlamentu& & Hamilton \\ \hline
    
    
    \end{tabular}
\end{center}


\newpage
\subsection{Tijdeman}
\subsubsection{Sformułowanie problemu}
\begin{description}
\item[k] oddziałów towarzystwa
\item[$\lambda$i] znormalizowana liczba członków w oddziale i, i=1,..,k
\item \begin{equation}
\sum \limits_{i}^{K} \lambda i = 1
\end{equation}
\item[$\omega$i] numer oddziału, którego pochodził przewodniczący w okresie j; j=1,..;
\item[A$\omega$(i,n)] liczba przewodniczących z oddziału i w okresie [1,n]; 
\item zminimalizować D($\omega$)=
\end{description}

\subsubsection{Rozwiązanie}
\begin{equation}
\min\limits_{i,n}\left | \lambda in - A\omega(i,n)\right | \leq 1-\frac{1}{2K-2}
\end{equation}
\subsubsection{Wyznaczanie oddziałów spełniających nierówność}
\begin{equation}
\sigma i = \lambda in - A\omega (i,n-1) \geq \frac{1}{2K-2}
\end{equation}
\begin{equation}
\frac{1-\frac{1}{2K-2}-\sigma i}{\lambda i} \to min
\end{equation}
\subsection{Steinera-Yeomansa}
\subsubsection{Algorytm}
\subsubsection{Przykład}
\subsection{Inmana-Bulfina}
\subsubsection{Algorytm}
\subsubsection{Przykład}
\subsection{Zamiana w PRV}
\section{Szeregowanie zadań}
\subsection{Problem Liu-Laylanda}
\subsubsection{Sformułowanie problemu}
\begin{itemize}
\item jeden proces,
\item n cyklicznych, niezależnych, podzielnych zadań o czasie wykonania Ci i okresie Ti,
\item zadanie musi być wykonane w okresie Ti
\end{itemize}
\subsubsection{Własności}
\subsubsection{Algorytm statyczny}
\begin{itemize}
\item posortuj zadania rosnąco według okresów Ti
\item zadanie o krótszym okresie ma większy priorytet
\item wykonuj zadanie tak długo jak nie pojawi się zadanie o wyższym priorytecie
\end{itemize}
\subsubsection{Algorytm dynamiczny}
\begin{itemize}
\item wyznacz dla każdego zadania linię krytyczną
\item zadanie posiadające najbliższą linię krytyczną ma największy priorytet
\item współczynnik wykorzystania pracy procesora
\begin{equation}
U=\sum\limits_{i=1}^{n}\frac{Ci}{Ti}
\end{equation}
\item dla algorytmu ze stałym priorytetem
\begin{equation}
U=m(\sqrt[m]{2}-1)
\end{equation}
\end{itemize}
\subsubsection{Przykład statyczny}
\subsubsection{Przykład dynamiczny}
\subsection{MAD - Mean Absolute Deviation}
\subsubsection{Sformułowanie problemu}
\begin{itemize}
\item szeregowanie zadań na jednej maszynie
\item n niezależnych i niepodzielnych zadań
\item jeden, wspólny, żądany termin zakończenia dla wszystkich zadań di=d dla wszystkich i
\item ti czas wykonania zadania i
\item fi(ei)=ei; gi(ti)=ti
\item wyprowadzenie funkcji celu
\begin{equation}
\sum\limits_{i=1}^{n}\left | Ci-d \right |
\end{equation}
\subsubsection{Własności}
\item najdłuższe zadanie uszeregowane jako pierwsze
\item no idle time - brak przerwy mieędzy zadaniami
\item V-shape uszeregowane zadania przed terminem zakończenia są uporządkowane według nierosnących czasów wykonania zadania, natomiast zadania które są uszeregowane po terminie zakończenia są uporządkowane według niemalejących czasów wykonania
\item jedno zadanie kończy się dokładnie w żadanym terminie zakończenia $\left \lceil \frac{n}{2} \right \rceil$ zadań kończy się przed lub w żądanym terminie zakończenia
\item problem restryktywny może przecinać zadanie
\end{itemize}
\subsubsection{Algorytm dla problemu nierestryktywnego}
Algorym Kaneta
\begin{enumerate}
\item E=$\phi$, T=$\phi$
\item WHILE J$\neq \phi$ DO

BEGIN
Remove a job k from J such that pi = max{pi}
Insert job k into the last position in E.
If J!=0 DO
BEGIN remove a job k from J such taht pi=max(pi)
insert a job k into the first position in T
END
END
S=(E,T) (konkatenacja)
\end{enumerate}
\subsubsection{Algorytm dla problemu restryktywnego}
\subsubsection{Przykład dla problemu nierestryktywnego}
\subsubsection{Przykład dla problemu restryktywnego}
\subsection{WSAD weighted sum of absolute deviations}
\subsubsection{Sformułowanie problemu}
\begin{itemize}
\item n niezależnych, niepodzielnych zadań
\item pi czas wykonania zadania i, i=1,..,n
\item d wspólny, żądany termin zakończenia
\item $\alpha$ jednostkowy koszt wykonania zadania przed terminem
\item $\beta$ jednostkowy koszt wykonania zadania po terminie
\item cel: zminimalizować \begin{equation}
\sum\limits_{i=1}^{n}(\alpha ei+\beta ti)
\end{equation}
\end{itemize}
\subsubsection{Własności}
\begin{itemize}
\item no idle time
\item V-shape
\item dla problemu unrestricted zadanie k, gdzie $\left \lceil k^*=\frac{\beta n}{\alpha + \beta} \right \rceil$ kończy się w chwili d
\end{itemize}
\subsubsection{Algorytm dla problemu nierestryktywnego}
Algorytm unrestricted (Bagchi, Sullivan, Chang, 1987)
\begin{itemize}
	\item Zadania uporządkowane są według LPT (od najdłuższego)
	\item |E| liczba zadań w zbiorze E (przed terminem)
	\item |T| liczba zadań w zbiorze T (po terminie)
	
	Krok 1. Zbiór E, T=0
	Krok 2 For k=1 TO n DO
	BEGIN
	usuń zadanie k ze zbioru J
	IF $(\alpha * |E|)<(\beta *(|T|+1))$ dodaj zadanie jako ostatnie do zbioru E
	ELSE dodaj na początek zbioru T
	END
	S=(E+T)
\end{itemize}
\subsubsection{Algorytm dla problemu restryktywnego}
\subsubsection{Przykład dla problemu nierestryktywnego}
\subsubsection{Przykład dla problemu restryktywnego}
\subsubsection{Właściwości}
\begin{itemize}
\item NP trudny w zwykłym sensie
\item zadania uporządtkowane SPT (niemalejąco)
\end{itemize}
\subsubsection{Omówienie algorytmu}
Szereguję zadanie (k+1)
\begin{itemize}
\item szereguję z lewej strony

$h_{k+1}^{L}=[\max(s+p_{k+1}-d,0)\beta + \alpha\max(d-s-p_{k-1},0)]+h_{k}^{*}(s+p_{k+1})$
\item szereguję z prawej strony

$h_{k+1}^{p}=\beta\left | (s+\sum\limits_{i}^{k}p_{i} \right | +h_{k}^{*}(s)$, dla spełnionego warunku $(s+\sum\limits_{i=1}^{|n|}p_{i}\geq d)$
\item $h_{k+1}^{*}(s)=\min(h_{k+1}^{L}(s), h_{k+1}^{p}(s))$
\item $h_{n}^{*}=\min h_{n}^{*}(s)$
\end{itemize}
\subsection{Wsad z elastycznym czasem wykonania zadania}
\subsubsection{Sformułowanie problemu}
\begin{itemize}
\item n zadań niezależnych i niepodzielnych
\item $p_{i}$ nominalny czas wykonania zadania i
\item $m_{i}$ maksymalne skrócenie zadania i
\item $p_{i}'$ rzeczywisty czas po skróceniu
\item $x_{i}$ rzeczywiste skrócenie
\item $\gamma_{i}$ koszt skrocenia zadania i o jednostkę
\item $\alpha$, $\beta$, d jak poprzednio, d nierestryktywne
\end{itemize}
\subsubsection{Funkcja celu}
Zminimalizować $\sum\limits_{i}^{n}(\alpha e_{i}+\beta t_{i} + \gamma_{i}x_{i})$
\subsubsection{Własności}
\begin{itemize}
\item no idle time
\item V-shape względem czasów $p_{i}'$
\item k kończy się w d, $k=\left \lceil \frac{n\beta}{\alpha+\beta} \right \rceil$
\item Wzór na długość zadań przed i po terminie wykonania: 

$\sum=\alpha(L_{1}+2L_{2}+...+(k-1)L_{k})+\beta((n-k)R_{1}+(n-k-1)R_{2}+...+R_{n-k})$
\item koszt uszeregowania zadania i na pozycji k: $C_{ik}=p_{i}\omega_{k}$
\item $\gamma_{i}<\omega_{k}, \gamma_{i}=\omega_{k}$ opłaca się skracać maksymalnie
\item $\gamma_{i}>\omega_{k}$ nie opłaca się skracać
\item $C_{ik} = \left\{\begin{matrix}
p_{i}'\omega_{k}+m_{i}\gamma_{i}$, gdy $\gamma_{i}<\omega_{k}\\ 
p_{i}\omega_{k}$, gdy $\gamma_{i}>\omega_{k}
\end{matrix}\right.$
\item Problem przydziału
\begin{itemize}
\item Zminimalizować $\sum\limits_{i=1}^{n}\sum\limits_{k=1}^{n}C_{ik}y_{ik}$ przy ograniczeniach:
\item $\sum\limits_{i=1}^{n} y_{ik}=1$, k=1,...,n
\item $\sum\limits_{i=1}^{k} y_{ik}=1$, i=1,...,n
\item $y_{ik}=\{0,1\}$
\item $y_{ik} = \left\{\begin{matrix}
1$, gdy zadanie i jest uszeregowane na pozycji k$\\ 
0$, w przeciwnym razie$
\end{matrix}\right.$
\end{itemize}
\end{itemize}
\subsubsection{Algorytm}
\subsubsection{Przykład}
\subsection{Problem z symetrycznymi wagami}
\subsubsection{Sformułowanie problemu}
\begin{itemize}
\item n niepodzielnych, niezależnych zadań
\item $p_{i}$ czas wykonania zadania i
\item $\alpha_{i} =\beta_{i}$ jednostkowy koszt wykonania zadania przed lub po terminie
\item d wspólny żądany termin zakończenia
\subsubsection{Funkcja celu}
Wyprowadzenie: $\sum\limits_{i=1}^{n}(e_{i}\alpha_{i}+\beta_{i}t_{i}) = \sum\limits_{i=1}^{n}\alpha_{i}(e_{i}+t_{i}) = \sum\limits_{i=1}^{n}\alpha_{i}\left | C_{i} - d \right |$

Funkcja celu: $\sum\limits_{i=1}^{n}\alpha_{i}\left | C_{i} - d \right |$
\end{itemize}
\subsubsection{Własności}
\begin{itemize}
\item no idle time
\item V-shape względem $\frac{p_{i}}{\alpha_{i}}$
\item NP-trudny, nawet w wersji nieretryktywnej
\item zadania posortowane według niemalejącej wartości $\frac{p_{i}}{\alpha_{i}}$
\end{itemize}
\subsubsection{Algorytm programowania dynamicznego}
\begin{itemize}
\item $h_{k}^{L}(s) = h_{k-1}^{*}(s+p_{k}) + \alpha_{k} \left | d-(s+p_{k} \right |$
\item $h_{k}^{p}(s) = h_{k-1}^{*}(s) + \alpha_{k} \left | \sum\limits_{i=1}^{k} p_{k}+s-d \right |$
\item $h_{k}^{*}(s)=\min(h_{k}^{L}(s), h_{k}^{p}(s))$
\item $h_{0}=0$
\item $h_{n}^{*} = {h_{k}^{*}(s), s=0,1,...}$
\end{itemize}
\subsubsection{Przykład}
\subsection{TWET - total weighted...}
\subsubsection{Sformułowanie problemu}
\begin{itemize}
\item n niezależnych, niepodzielnych zadań
\item pi czas wykonania zadania i
\item $\alpha i$ jednostkowy koszt wykonania zadania i przed terminem
\item $\beta i$ jednostkowy koszt wykonania zadania i po terminie
\item d wspólny żądany termin zakończenia

\subsubsection{Funkcja celu}
zminimalizować $\sum\limits_{i=1}^{n}(\alpha i ei + \beta iti)$
\subsubsection{Własności}
\item no idle time
\item non-restriced - jedno zadanie kończy się w due-date
\item NP-trudny nawet dla przypadku nierestryktywnego
\item $E \in \{ Ci<d \}, T \in\{Ci\geq d\}$, zadania w zbiorze T są uszeregowane według niemaljącej wartości $\frac{pi}{\beta i}$, a zadania w zbiorze E są uszeregowane według nierosnącej wartości $\frac{pi}{\alpha i}$
\item uszeregowanie optymalne \begin{equation}
\sum\limits_{i\in T} \beta i \leq \sum\limits_{j \in Ei} \alpha j
\end{equation}
\item jeżeli znamy optymalny podział zadań na zbiory E i T, to znalezienie uszeregowania optymalnego jest łatwe
\item istnieje algorytm pseudo-wielomianowy dla szczególnego przypadku, gdy dla każdego i i j \begin{equation}
(\frac{pi}{\alpha i} < \frac{pj}{\alpha j}) \Rightarrow (\frac{pi}{\beta i} < \frac{pj}{\beta j})
\end{equation}
\end{itemize}
\subsubsection{Algorytm pełnego przeglądu}
\begin{enumerate}
\item Porządkowanie zadań według nierosnących wartości $\frac{pi}{\alpha i}$
\item Wszystkie zadania umieszczamy w zbiorze E
\item Na każdym poziomie przenosimy jedno zadanie ze zbioru E na początek zbioru T
\item Jeżeli naruszone są warunki (I) lub (II) to kończymy gałąź. Jeżeli uszeregowanie jest dopuszczalne, to obliczamy jego koszt.
\item Rozwijamy drzewo do sprawdzenia wszystkich dopuszczalnych uszeregowań
\end{enumerate}
\subsubsection{Przykład}
\subsection{CTV - Completion Time Variance}
\subsubsection{Sformułowanie problemu}
\begin{itemize}
\item n niezależnych, niepodzielnych zadań
\item d wspólny, żądany termin zakończenia
\item pi czas wykonania zadania i=1,..,n
\item $\alpha i = \beta i = 1$ i=1,..,n
\end{itemize}
\subsubsection{Funkcja celu}
Zminimalizować $\sum\limits_{i=1}^{n}(Ci-d)^2$
\subsubsection{Własności}
\begin{itemize}
\item $d=\frac{1}{n}\sum\limits_{i=1}{n}Ci$
\item $\sum\limits_{i=1}^{n}(C_{i}-\frac{1}{n}\sum\limits_{i=1}^{n}C_{i})^2 = \sum\limits_{i=1}^{n}(C_{i}- \bar{C_{i}})^2$ wariancja Ci
\item no idle time
\item najdłuższe zadanie uszeregowane jako pierwsze
\item V-shape
\item Algorytm Kaneta nie daje poprawnego rozwiazania problemu
\item problem NP-trudny
\item Zminimalizować $\sum\limits_{i=1}^{n}(C_{i}-d)^k k>0$
\begin{itemize}
\item 0$<$k$\leq$ 1 problem wielomianowy, algorytm Kaneta
\item k$\geq$ 2 problem NP-trudny
\item 1$<$k$<$2 problem otwarty
\end{itemize}
\end{itemize}
\subsubsection{Algorytm}
\begin{itemize}
\item algorytm programowania dynamicznego
\item algorytm podziału i ograniczeń
\item metaheurystyki
\item algorytmy spektralne 
\end{itemize}
\subsubsection{Algorytm programowania dynamicznego}
\begin{itemize}
\item zamiast wartości bezwzględnej, kwadrat
\item $h_{k}^{L}(s)= h_{k-1}^{*}(s+p_{k})+(s+p_{k}-d)^2$
\item $h_{k}^{p}(s)=h_{k-1}^{*}(s)+(s+\sum\limits_{i=1}^{k}p_{k} -d)^2$
\item $h_{k}^{*}= \min\{h_{k}^{L}(s),h_{k}^{p}(s)\}$
\item $h_{0}^{*}(s)=0$
\item $h_{n}^{*}= \min\limits_{n} h_{n}^{*}(s)$
\end{itemize}
\subsection{Ten algorytm z tym takim wykresem fajnym}
\subsubsection{Sformułowanie problemu}
\begin{itemize}
\item n niezależnych, niepodzielnych zadań
\item jedna maszyna
\item $d_{i}$ żądany termin zakończenia zadania i
\item $\alpha_{i}$ jednostkowy koszt wykonania zadania i przed terminem
\item $\beta_{i}$ jednostkowy koszt wykonania zadania i po terminie
\end{itemize}
\subsubsection{Funkcja celu}
$\sum\limits_{i=1}^{n}(\lambda_{i}e_{i}+\beta_{i}t_{i})$
\subsubsection{Dodatkowe ograniczenie}
brak przerw w pracy procesora
\subsubsection{Właściwości}
\begin{itemize}
\item nawet dla przypadku $\alpha_{i}=\beta_{i}=1$ problem jest silnie NP-trudny
\item w literaturze rozważa się również przypadek z dodatkowym ograniczeniem na brak przerw w pracy procesora
\item dla znanej sekwencji zadań ich optymalne położenie na osi czasu można znaleźć w czasie O(n) (wielomianowym zależnym od liczby zadań)\begin{itemize}
\item model programowania liniowego
\item algorytm zachłanny O(n$log_{n}$)
\end{itemize}
\end{itemize}
\subsubsection{Programowanie liniowe}
\begin{itemize}
\item Zmienna decyzyjna $C_{i}$ (termin zakończenia zadania i)
\item Funkcja celu $\sum\limits_{i=1}^{n}(\alpha_{i}e_{i}+\beta_{i}t_{i})$
\item Ograniczenia
 \begin{itemize}
\item $e_{i} \geq d_{i}-C_{i}$
\item $e_{i} \geq 0$
\item $t_{i} \geq C_{i}-d_{i}$
\item $t_{i} \geq 0$
\item $C_{i+1} \geq C_{i} + p_{i+1}$
\item $C_{1} \geq p_{1}$
\end{itemize}
\item Liczba zmiennych: 3n
\item Liczba ograniczeń: 5n
\end{itemize}
\subsubsection{Przykład algorytm zachłanny}
I tutaj ten wykresik. Wymiekam
\end{document}
